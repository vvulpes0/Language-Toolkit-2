<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>LTK.Decide.Variety</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">language-toolkit-1.1.0.0: A set of tools for analyzing languages via logic and automata</span><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) 2023 Dakotah Lambert</td></tr><tr><th>License</th><td>MIT</td></tr><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">LTK.Decide.Variety</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Documentation</a></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module provides a general mechanism
  for constructing decision procedures
  given an equational characterization of a pseudovariety.
  One parses the collection of equations,
  quantifies universally over the bound variables,
  and determines whether all specified relationships hold.</p><p><em>Since: 1.1</em></p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:isVariety">isVariety</a> :: (<a href="https://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> n, <a href="https://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> e) =&gt; <a href="https://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> -&gt; <a href="https://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="LTK-FSA.html#t:FSA" title="LTK.FSA">FSA</a> n e -&gt; <a href="https://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="https://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:isVarietyM">isVarietyM</a> :: (<a href="https://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> n, <a href="https://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> e) =&gt; <a href="https://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> -&gt; <a href="https://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="LTK-Algebra.html#t:SynMon" title="LTK.Algebra">SynMon</a> n e -&gt; <a href="https://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="https://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Documentation</h1></a><div class="doc"><p>A (pseudo)variety is specified here by a system of equations.
  These equations may contain (single-letter) variables,
  which are universally quantified.
  The grammar is as follows:</p><pre>     expr ::= '[' conj-list ']'
conj-list ::= eq-list ';' conj-list | eq-list
  eq-list ::= value '=' eq-list | value '=' value
    value ::= value value | iter
     iter ::= '0' | '1' | LETTER | '(' value ')' | iter '*'</pre><p>Here, <code>LETTER</code> refers to any character which Unicode deems a letter.
  Concatenation is denoted by adjacency,
  and <code>x*</code> represents the unique element of the form
  <code>x</code>, <code>xx</code>, and so on, such that <code>x*x*=x*</code>.
  A <code>LETTER</code> represents a universally-quantified variable,
  while <code>0</code> and <code>1</code> refer to the unique elements where for all <code>x</code>
  it holds that <code>0x=0=x0</code> and <code>1x=x=x1</code>,
  if such elements exist.
  If <code>0</code> or <code>1</code> is used in an equation,
  but the given structure lacks such an element,
  then the structure of course does not satisfy the equality.</p><p>The equality <code>x=y</code> asserts that,
  for all possible variable instantiations,
  the value of <code>x</code> is the same as that of <code>y</code>.
  For longer chains of equality, all values must be equal.
  Then <code>[e1;e2]</code> asserts that the equalities <code>e1</code> and <code>e2</code>
  both hold universally.
  Essentially, the semicolon is an &quot;and&quot; operator.</p><p>Suppose we wish to express the *-variety
  of idempotent and commutative monoids.
  A monoid is idempotent if and only if it holds that <code>xx=x</code>
  for all values <code>x</code>, which can also be expressed as <code>x*=x</code>.
  It is commutative if and only if <code>ab=ba</code> for all <code>a</code> and <code>b</code>.
  This variety could then be expressed as <code>[ab=ba;x*=x]</code>.</p></div><div class="top"><p class="src"><a id="v:isVariety" class="def">isVariety</a> :: (<a href="https://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> n, <a href="https://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> e) =&gt; <a href="https://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> -&gt; <a href="https://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="LTK-FSA.html#t:FSA" title="LTK.FSA">FSA</a> n e -&gt; <a href="https://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="https://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:isVariety" class="selflink">#</a></p><div class="doc"><p>The <code>isVariety star desc</code> function is equivalent to
 <code>isVarietyM star desc . syntacticMonoid</code>.</p></div></div><div class="top"><p class="src"><a id="v:isVarietyM" class="def">isVarietyM</a> :: (<a href="https://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> n, <a href="https://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> e) =&gt; <a href="https://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> -&gt; <a href="https://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="LTK-Algebra.html#t:SynMon" title="LTK.Algebra">SynMon</a> n e -&gt; <a href="https://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="https://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:isVarietyM" class="selflink">#</a></p><div class="doc"><p>Determine whether a given semigroup is in the pseudovariety
 described by the given equation set.
 Returns Nothing if and only if the equation set cannot be parsed.
 The Boolean operand determines whether
 to check for a *-variety (True) or a +-variety (False).
 In other words, it determines whether the class containing
 the empty string is included.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.26.0</p></div></body></html>