> {-# OPTIONS_HADDOCK show-extensions #-}
> {-|
> Module    : LTK.Decide.FO2
> Copyright : (c) 2021 Dakotah Lambert
> License   : MIT

> This module implements an algorithm to decide whether a given FSA
> is representable in two-variable logic based on the semigroup
> characterization as reported by ThÃ©rien and Wilke in their 1998
> STOC article: https://doi.org/10.1145/276698.276749

> Two-variable logic with general precedence is a strict superclass
> of PT while still being a strict subclass of star-free.  It
> represents exactly the class of properties expressible in temporal
> logic using only the "eventually in the future/past" operators.

> The section regarding betweenness is built on Krebs et al. (2020):
> https://doi.org/10.23638/LMCS-16(3:16)2020
> -}
> module LTK.Decide.FO2 (isFO2, isFO2B, isFO2S) where

> import Data.Set (Set)
> import qualified Data.Set as Set

> import LTK.FSA

> type S n e = (n, [Symbol e])
> type T n e = State (S n e)

> -- |True iff the automaton recognizes a stringset
> -- representable in \(\mathrm{FO}^{2}[<]\).
> isFO2 :: (Ord n, Ord e) => FSA n e -> Bool
> isFO2 fsa = let s = syntacticMonoid fsa
>             in fo2test s (states s) -- use the entire semigroup

A language is FO2[<,+1]-definable iff
for all idempotents e of its semigroup (not monoid) S,
the subsemigroup eSe corresponds to something FO2[<]-definable

> -- |True iff the automaton recognizes a stringset
> -- representable in \(\mathrm{FO}^{2}[<,+1]\).
> isFO2S :: (Ord n, Ord e) => FSA n e -> Bool
> isFO2S fsa = let s = syntacticMonoid fsa
>              in all (fo2test s . generatedSubsemigroup s)
>                 $ Set.toList (idempotents s)



A syntactic monoid represents an FO2[<]-definable language
iff for all elements x, y, and z it is the case that
(xyz)^{\omega}*y*(xyz)^{\omega} = (xyz)^{\omega}, where
s^{\omega} is the unique element where s^{\omega}*s = s^{\omega}.
This operation is defined for all elements when the monoid comes
from something star-free.

> -- |True iff the submonoid of @monoid@ given by @xs@ is in DA.
> -- Results are unspecified if @xs@ is not actually a submonoid.
> fo2test :: (Ord n, Ord e) => FSA (S n e) e -> Set (State (S n e))-> Bool
> fo2test monoid xs = trivialUnder hEquivalence monoid -- isSF
>                     && (all f $ triples xs) -- in DA
>     where f (x, y, z) = let xyzw = omega monoid ((x $*$ y) $*$ z)
>                         in (xyzw $*$ y) $*$ xyzw == xyzw
>           a $*$ b = Set.findMin $ follow monoid (snd (nodeLabel b)) a

> -- |@omega monoid s@ is the unique element \(t\) where \(t*t\) = \(t\)
> -- and \(t\) is in \(\{s, s^2, s^3, \ldots\}\).
> -- In other words, \(t\) is the unique idempotent element
> -- in this set.
> -- This method used here assumes @monoid@ is aperiodic and finite
> -- and uses this to skip many otherwise necessary checks.
> omega :: (Ord n, Ord e) => FSA (S n e) e -> T n e -> T n e
> omega monoid s = fst
>                  . until (uncurry (==)) (\(_,b) -> (b, f b))
>                  $ (s, f s)
>     where f x = Set.findMin $ follow monoid (snd (nodeLabel x)) x

The subsemigroup of S generated by x is the set xSx.
xS is the set of all things reachable from x in the graph,
then from there we follow x again.

> generatedSubsemigroup :: (Ord n, Ord e) =>
>                          FSA (n, [Symbol e]) e -> State (n, [Symbol e]) ->
>                          Set (State (n, [Symbol e]))
> generatedSubsemigroup f x
>     = collapse (union . follow f (snd $ nodeLabel x)) empty $
>       primitiveIdealR f x


For betweenness:

For a monid M and idempotent e, Me is the set
    {m : e is in the two-sided ideal of m}.
The class MeV, for some variety V, is the set of all monoids M
where for all idempotents e, e*Me*e is in V.

A language is representable in FO2[<,bet] iff its syntactic monoid
is in MeDA.

> me :: (Ord n, Ord e) => FSA (S n e) e -> T n e -> Set (T n e)
> me monoid e = keep (contains e . primitiveIdeal2 monoid)
>               $ states monoid

emee is e*Me*e: first follow the label of e from all the states,
then take the resulting labels and follow those from e.

> emee :: (Ord n, Ord e) => FSA (S n e) e -> T n e -> Set (T n e)
> emee monoid e = collapse (union . flip (follow monoid) e . s) empty
>                 . collapse (union . follow monoid (s e)) empty
>                 $ x
>     where x = me monoid e
>           s = snd . nodeLabel

> -- |True iff the automaton recognizes a stringset
> -- representable in \(\mathrm{FO}^{2}[<,\mathrm{bet}]\).
> -- Labelling relations come in the typical unary variety
> -- \(\sigma(x)\) meaning a \(\sigma\) appears at position \(x\),
> -- and also in a binary variety
> -- \(\sigma(x,y)\) meaning a \(\sigma\) appears strictly between
> -- the positions \(x\) and \(y\).
> isFO2B :: (Ord n, Ord e) => FSA n e -> Bool
> isFO2B fsa = let s = syntacticMonoid fsa
>              in all (fo2test s . emee s)
>                 $ Set.toList (idempotents s)



An element x is idempotent iff xx == x.
Here we use the syntactic monoid and simply exclude the identity
if it does not appear in the syntactic semigroup.

> idempotents :: (Ord n, Ord e) =>
>                FSA (n, [Symbol e]) e -> Set (State (n, [Symbol e]))
> idempotents f = keep isIdem . tmap destination $ transitions f
>     where isIdem x = follow f (snd $ nodeLabel x) x == singleton x

> pairs :: Ord a => Set a -> Set (a, a)
> pairs xs = collapse (union . f) empty xs
>     where f x = Set.mapMonotonic ((,) x) xs

> triples :: Ord a => Set a -> Set (a, a, a)
> triples xs = collapse (union . f) empty (pairs xs)
>     where f (a, b) = Set.mapMonotonic (\x -> (x, a, b)) xs
